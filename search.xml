<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【机器学习】浅谈机器学习原理</title>
      <link href="/2025/03/02/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%9B%B4%E6%96%B0%E9%A2%84%E5%91%8A%EF%BC%9A%E6%B5%85%E8%B0%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8E%9F%E7%90%86/"/>
      <url>/2025/03/02/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%9B%B4%E6%96%B0%E9%A2%84%E5%91%8A%EF%BC%9A%E6%B5%85%E8%B0%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>最近入门多模态大模型时听了Hung-yi Li的机器学习，受益匪浅，故想要更一篇。</p><p>我要不知道要多久（busy.jpg）更出来，因为还有一篇（想要两篇一起更）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【C &amp;&amp; JavaScript】关于Closure（闭包）</title>
      <link href="/2025/02/06/%E3%80%90C%20&amp;&amp;%20JavaScript%E3%80%91%E5%85%B3%E4%BA%8EClosure%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/"/>
      <url>/2025/02/06/%E3%80%90C%20&amp;&amp;%20JavaScript%E3%80%91%E5%85%B3%E4%BA%8EClosure%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="何为闭包？"><a href="#何为闭包？" class="headerlink" title="何为闭包？"></a>何为闭包？</h1><p>这里将通过C语言中的一些案例来介绍闭包。本想默认读者都具备一定的指针知识，但考虑到我自己也忘记了许多指针的东西<del>（到底是什么人在非必要情况下用C）</del>，不如在这里简单写一下，顺便当作我自己的复习。</p><h2 id="C-中的指针"><a href="#C-中的指针" class="headerlink" title="C 中的指针"></a>C 中的指针</h2><p>YouTube上有一名叫Cherno的程序员（bilibili有转载）说过一句我铭记至今的话：<strong>指针就是一个值，只不过这个值是地址而已</strong>，但我个人认为这句话并不完整，还应该加上“<strong>单位</strong>”。</p><p><strong>（IMPORTANT）</strong>何为指针的“单位”？众所周知，假设有一个长度为3的一维整形数组<code>arr = &#123;1, 2, 3&#125;</code>，数值上<code>arr = &amp;arr</code>（这里假设都为<code>0x9F36FAE0</code>）。但你并不能认为对<code>arr</code>和<code>&amp;arr</code>做相同操作得到的结果是相同的，因为它们所处的“地位”是不同的。你可以认为<code>arr</code>是指向于数组起始元素的指针，因此<code>arr</code>的指针类型为<code>int [3]</code>，其元素的<code>sizeof</code>为<code>sizeof(int) = 4</code>，<code>arr + 1</code>自然为第二个元素的地址<code>0x9F36FAE4</code>；而<code>&amp;arr</code>从字面意思上即可知道，它代表整个数组的地址，指向的是整个数组，也就是说<code>&amp;arr</code>站在更高一层，其指针类型为<code>int(*) [3]</code>，其元素为数组，<code>sizeof</code>为12，这时对<code>&amp;arr</code>加一，得到的结果便是<code>0x9F36FAEC</code>.</p><p>由此可见，指针的“单位”取决于其“定位”，可以简单的理解为它究竟指向于什么。</p><p>如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> test_arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> *point_arr[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    point_arr[i] = test_arr[i];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以花上几秒钟思考，<code>point_arr</code>的元素是什么？首先<code>point_arr</code>被定义为指针数组，其内的元素分别被赋值为两个一维数组，它们的指针类型都是<code>int [3]</code>，即<code>point_arr[i]</code>的指针类型为<code>int [3]</code>。我们可以试着解析一下<code>*(*(point_arr + i) + j)</code>：由之前所述，<code>point_arr + i</code>代表了<code>&amp;point_arr[i]</code>，因此<code>*(point_arr + i)</code>代表了<code>point_arr[i]</code>这个<code>int [3]</code>，故<code>*(point_arr + i) + j</code>代表了<code>&amp;test_arr[i][j]</code>，因此<code>*(*(point_arr + i) + j)</code>代表<code>test_arr[i][j]</code>。</p><p>这和二维数组行指针有异曲同工之妙，行指针定义形式为<code>int (*row_ptr)[3] = test_arr</code>，<code>row_ptr</code>的指针类型为<code>int [2][3]</code>，与一维数组同理，<code>row_ptr + i</code>为第i个元素的地址（在这里第i个元素为数组），即为第i个数组的地址，也就是说<code>row_ptr + i</code>的指针类型为<code>int(*) [3]</code>，那么<code>*(row_ptr + i) + j</code>即为<code>&amp;test_arr[i][j]</code>，进而<code>*(*(row_ptr + i) + j)</code>为<code>test_arr[i][j]</code>。</p><p>说都说到这了不如再提一下列指针（），其实只用理解不管是几维数组，其元素排列都是线性的就可以了，因此<code>int *p = &amp;test_arr[0][0]</code>即可定义列指针，至于怎样取元素就只是一个简单的数学问题了，比如要取<code>test_arr[i][j]</code>，要先跨i行，再跨j列，即<code>*(p + i * 3 + j)</code>.</p><p>（我个人认为把上面这几行读懂，指针也就理解的差不多了）</p><h2 id="C-中的-callback-function"><a href="#C-中的-callback-function" class="headerlink" title="C 中的 callback function"></a>C 中的 callback function</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>顾名思义，函数指针即指向函数的指针，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*func_ptr)(<span class="type">double</span>, <span class="type">char</span>) = func;</span><br></pre></td></tr></table></figure><p>定义了一个名为<code>func_ptr</code>的函数指针，其指向了参数列表为<code>(double, char)</code>、返回<code>int</code>的<code>func</code>。与数组指针不同的是，函数指针赋值时，赋值符右边可以为<code>func</code>，也可以是<code>&amp;func</code>，对于函数而言，它们是等价的。函数指针的调用可以是下面这两种等价的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*func_ptr)(<span class="number">1.0</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">func_ptr(<span class="number">1.0</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以来看看下面这行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(* (<span class="type">void</span>(*)()) <span class="number">0</span>)(); </span><br></pre></td></tr></table></figure><p><code>0</code>被强制转换为了<code>void(*)()</code>类型，于是这行代码意味着调用地址为0的函数，而事实上，C语言中指向0地址的指针是一个空指针。</p><p>又如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>(* signal_func(<span class="type">int</span>, <span class="type">void</span>(*)(<span class="type">int</span>)) )(<span class="type">int</span>)&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先要明确，<strong><code>void(*)(int)</code>是一个函数指针类型</strong>，故这个函数返回此类型的函数指针，因此函数名为<code>signal_func</code>，参数列表为<code>int</code>、<code>void(*)(int)</code>，返回值为<code>void(*)(int)</code>。</p><p>当然还有函数指针数组，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设已经定义了四个运算函数Add, Sub, Mul, Div，接收两个double并返回double</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">double</span> <span class="params">(* operator)</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    operator ops[<span class="number">4</span>] = &#123;Add, Sub, Mul, Div&#125;;</span><br><span class="line">    <span class="comment">// ops[0](1.5, 2.5); =&gt; Add(1.5, 2.5);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="callback-function"><a href="#callback-function" class="headerlink" title="callback function"></a>callback function</h3><p>所谓callback function，即回调函数，是指将一个函数作为参数传递给另一个函数，并在特定事件或条件发生时由后者调用，其核心思想是 “你定义，我调用”，即由调用方定义函数的具体行为，而被调用方在适当的时机执行该函数。这一点在JavaScript中极其常见，在JS中，以函数为参数的函数或以函数为返回值的函数为高阶函数，一个典型就是<code>forEach, addEventListener</code>，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> navContainer = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.nav&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> navLinks = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.nav__link&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> navLinksGrayFunc = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleHover</span> = (<span class="params">event, opacity</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">grayFunc</span> = (<span class="params">opacity, targetLink</span>) =&gt; &#123;</span><br><span class="line">            logo.<span class="property">style</span>.<span class="property">opacity</span> = opacity;</span><br><span class="line">            navLinks.<span class="title function_">forEach</span>(<span class="function"><span class="params">link</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (link !== targetLink) link.<span class="property">style</span>.<span class="property">opacity</span> = opacity;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        event.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;nav__link&#x27;</span>) &amp;&amp; (<span class="keyword">function</span> (<span class="params">opacity, targetLink</span>) &#123;</span><br><span class="line">            <span class="title function_">grayFunc</span>(opacity, targetLink);</span><br><span class="line">        &#125;)(opacity, event.<span class="property">target</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    navContainer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> <span class="title function_">handleHover</span>(event, <span class="number">0.5</span>));</span><br><span class="line">    navContainer.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> <span class="title function_">handleHover</span>(event, <span class="number">1</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里即向<code>navLinks.forEach</code>内传递了一个函数定义，<code>addEventListener</code>的第二个参数也是一个函数定义，它们都实现了callback function，即在特定时机调用（假如你看不懂<code>JavaScript</code>，不对，那你为什么会点进来？）。</p><p>我们同样可以用函数指针来实现callback function，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (* signal_func(<span class="type">int</span> signum, <span class="type">void</span>(* handler)(<span class="type">int</span>)))(<span class="type">int</span>)&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> pre_handler = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void</span> (*temp)(<span class="type">int</span>) = pre_handler;</span><br><span class="line">    pre_handler = handler;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler1</span><span class="params">(<span class="type">int</span> intnum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d ,handler1\n&quot;</span>, intnum);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler2</span><span class="params">(<span class="type">int</span> intnum)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d ,handler2\n&quot;</span>, intnum);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> (* pre_handler)(<span class="type">int</span>) = signal_func(<span class="number">1</span>, handler1);<span class="comment">// 得到NULL</span></span><br><span class="line">    pre_handler = signal_func(<span class="number">1</span>, handler2);<span class="comment">// 得到handler1这个函数指针</span></span><br><span class="line">    pre_handler(<span class="number">2</span>);<span class="comment">// 2, handler1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="JavaScript-中的-closure（闭包）"><a href="#JavaScript-中的-closure（闭包）" class="headerlink" title="JavaScript 中的 closure（闭包）"></a>JavaScript 中的 closure（闭包）</h3><p>C 语言的函数指针获取的是函数环境，但并没有办法获取到函数“诞生”的环境，但JavaScript可以做到，即<strong>闭包 = 函数 + 该函数创建时的词法环境</strong>。也就是说，当一个函数记住并访问其创建时的作用域(即使在该作用域外执行)，就形成了闭包。这是JavaScript的固定行为，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// Private variable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ++count;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>（C语言不能在函数内部定义函数，至少C89是这样的）执行<code>counter()</code>时，不在其函数作用域中的<code>count</code>居然被神奇的获取到了，因为它被<code>createCounter</code>函数创建时，<code>count</code>被保存在<code>createCounter</code>函数的词法环境，调用<code>counter</code>函数可以访问到<code>createCounter</code>函数的词法环境，从而访问到<code>count</code>。</p><p>我们当然可以在C语言中使用结构体与函数指针模拟这一行为，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125; Counter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*CounterFunction)</span><span class="params">(Counter*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">incrementCounter</span><span class="params">(Counter* counter)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ++(counter-&gt;count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CounterFunction <span class="title function_">createCounter</span><span class="params">(Counter* counter)</span> &#123;</span><br><span class="line">    counter-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> incrementCounter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Counter counter1, counter2;</span><br><span class="line"></span><br><span class="line">    CounterFunction counterFunc1 = createCounter(&amp;counter1);</span><br><span class="line">    CounterFunction counterFunc2 = createCounter(&amp;counter2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, counterFunc1(&amp;counter1)); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, counterFunc1(&amp;counter1)); <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, counterFunc2(&amp;counter2)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是<strong>注意：JS中，闭包 &gt; 全局作用域</strong>，这是闭包比较强大的地方。</p><h1 id="两个闭包的好例子"><a href="#两个闭包的好例子" class="headerlink" title="两个闭包的好例子"></a>两个闭包的好例子</h1><h2 id="模块模式：封装实现"><a href="#模块模式：封装实现" class="headerlink" title="模块模式：封装实现"></a>模块模式：封装实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Private state</span></span><br><span class="line">    <span class="keyword">let</span> memory = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Private method</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">logOperation</span>(<span class="params">op</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Performed operation: <span class="subst">$&#123;op&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Expose public API</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">            <span class="title function_">logOperation</span>(<span class="string">&#x27;Addition&#x27;</span>);</span><br><span class="line">            memory += x;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">getValue</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">add</span>(<span class="number">10</span>), calculator.<span class="title function_">getValue</span>());</span><br></pre></td></tr></table></figure><p>这个例子主要是想要强调<strong>在对象中创建的函数不是在非对象的环境中创建的</strong>，例如，<code>add</code>和<code>getValue</code>函数在IIFE中创建，因此它们可以访问IIFE的私有变量<code>memory</code>，并且可以访问IIFE的私有函数<code>logOperation</code>。</p><h2 id="事件处理程序：保留上下文"><a href="#事件处理程序：保留上下文" class="headerlink" title="事件处理程序：保留上下文"></a>事件处理程序：保留上下文</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupButtons</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// IIFE to capture current i value</span></span><br><span class="line">        (<span class="keyword">function</span> (<span class="params">index</span>) &#123;</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`btn-<span class="subst">$&#123;index&#125;</span>`</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Clicked button <span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>一些看似简单的东西往往会酿成错误：关于for循环和变量声明的认知刷新【在循环中使用IIFE或let声明来捕获迭代值的重要性】</strong></p><p>错误写法示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">problemDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`btn-<span class="subst">$&#123;i&#125;</span>`</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Clicked button <span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>var</code>声明的<code>i</code>是函数级作用域，整个循环共享同一个变量。实际等价于（看似很简单的<code>for</code>循环实际是这样的）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`btn-<span class="subst">$&#123;i&#125;</span>`</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, ...);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`btn-<span class="subst">$&#123;i&#125;</span>`</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, ...);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`btn-<span class="subst">$&#123;i&#125;</span>`</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, ...);</span><br></pre></td></tr></table></figure><h3 id="使用IIFE的解决方案："><a href="#使用IIFE的解决方案：" class="headerlink" title="使用IIFE的解决方案："></a>使用IIFE的解决方案：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">iifeSolution</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`btn-<span class="subst">$&#123;index&#125;</span>`</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Clicked button <span class="subst">$&#123;index&#125;</span>`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过IIFE创建新的函数作用域。当使用<code>var</code>声明的<code>i</code>作为参数传入时，事件回调函数会形成闭包，捕获当前作用域的<code>index</code>值。这种闭包通常发生在回调函数中。</p><h3 id="使用let的现代解决方案："><a href="#使用let的现代解决方案：" class="headerlink" title="使用let的现代解决方案："></a>使用let的现代解决方案：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">modernSolution</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">`btn-<span class="subst">$&#123;i&#125;</span>`</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Clicked button <span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次循环都会创建新的块级作用域。当使用<code>let</code>声明的<code>i</code>作为参数传入时，每个回调闭包都会捕获当前作用域的<code>i</code>值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【概率论与数理统计】多方法在次序统计量分布中的应用综述</title>
      <link href="/2025/01/20/%E3%80%90%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E3%80%91%E5%A4%9A%E6%96%B9%E6%B3%95%E5%9C%A8%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%88%86%E5%B8%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%BB%BC%E8%BF%B0/"/>
      <url>/2025/01/20/%E3%80%90%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E3%80%91%E5%A4%9A%E6%96%B9%E6%B3%95%E5%9C%A8%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%88%86%E5%B8%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>notice：本文的一些长公式你可以通过滚动条阅读，原谅我没有找到好的使得公式换行的方法，我已尝试了更换markdown渲染内核从marked到kramed，可惜我之前一些没有注意到的失误使得整个过程无法正常进行，除非我一切重来。</strong></p><h1 id="为什么做这个综述？"><a href="#为什么做这个综述？" class="headerlink" title="为什么做这个综述？"></a>为什么做这个综述？</h1><p>在我学习【概率论与数理统计】这门课的时候，一个环节是对均匀分布参数矩估计与最大似然估计之间的有效性比较，而后者则涉及了均匀分布次序统计量的均值、方差。一些文献所提出的关于均匀分布次序统计量的一些性质为计算参数估计量的方差提供了基础，他们直接给出了在均匀分布条件下单个次序统计量的概率密度函数，但没有提供直接的证明过程。</p><p>我发现目前关于均匀分布次序统计量的概率密度函数推导并不少，于是我开始幻想能不能将分布一般化。</p><p>我查阅了大量的资料得到了本文，主要焦点集中在推导次序统计量的概率密度函数。首先，回顾连续型随机变量中基于累积分布函数推导单个次序统计量分布的基本方法，阐述该方法与利用离散化处理作概率重构方法的等效性；此外，还将阐述如何结合概率微元的方法达成同样的目的，并为其在后文的延伸打下基础。接着，本文将探讨离散型随机变量情况下的次序统计量分布与连续型随机变量推导过程中的根本差异，并对其中的一些问题作讨论。</p><p>另外，本文还将对进一步扩展到多个次序统计量的分布推导作综述。通过以两个次序统计量为基础，逐步推导多个次序统计量的联合概率密度函数，这一推导过程扩展了单个次序统计量分布的推导方法。</p><p><strong>注：</strong> 需要说明的是，本文是对次序统计量分布推导方法的综述与复现，并非原创性的内容产出。</p><p>相关符号说明</p><div class="table-container"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>$X_1, X_2, \dots, X_n$</td><td>来自总体的 $n$ 个样本</td></tr><tr><td>$X_{(1)}, X_{(2)}, \dots, X_{(n)}$</td><td>$n$ 个样本中从小到大排序的次序统计量</td></tr><tr><td>$F(x)$</td><td>总体的累积分布函数</td></tr><tr><td>$f(x)$</td><td>总体的概率密度函数（连续型随机变量）</td></tr></tbody></table></div><h1 id="单个次序统计量的概率密度函数"><a href="#单个次序统计量的概率密度函数" class="headerlink" title="单个次序统计量的概率密度函数"></a>单个次序统计量的概率密度函数</h1><h2 id="基于累积分布函数的推导"><a href="#基于累积分布函数的推导" class="headerlink" title="基于累积分布函数的推导"></a>基于累积分布函数的推导</h2><p>由随机变量累积分布函数的定义可知：</p><script type="math/tex; mode=display">F_{X_{(k)}}(x) = P(X_{(k)} \le x)</script><p>由于 $ X_{(1)} \le X_{(2)} \le \dots \le X_{(n)} $，因此 $ X_{(k)} \le x $ 要求至少有$k$个样本值小于$x$。记$P=F(x)$，则有：</p><script type="math/tex; mode=display">F_{X_{(k)}}(x) = P(X_{(k)} \le x) = \sum_{i = k}^n \binom{n}{i} P^i (1 - P)^{n-i}</script><p>为进一步推导，需要证明下述等式：</p><script type="math/tex; mode=display">\sum_{i = k}^n \binom{n}{i} P^i (1 - P)^{n-i} = k \binom{n}{k} \int_{0}^P x^{k-1} (1 - x)^{n-k} \, dx</script><p><strong>证明：</strong></p><p>对于右式有：</p><script type="math/tex; mode=display">\frac{d}{d P} \left[ k \binom{n}{k} \int_{0}^P x^{k-1} (1 - x)^{n-k} \, dx \right] = k \binom{n}{k} P^{k-1} (1 - P)^{n-k}</script><p>对于左式有：</p><script type="math/tex; mode=display">\frac{d}{d P} \left[ \sum_{i=k}^n \binom{n}{i} P^i (1 - P)^{n-i} \right] = \sum_{i=k}^n \binom{n}{i} \left[ i P^{i-1} (1 - P)^{n-i} - (n - i) P^i (1 - P)^{n-i-1} \right] = k \binom{n}{k} P^{k-1} (1 - P)^{n-k} - (n - k) \binom{n}{k} P^k (1 - P)^{n-k-1} + (k + 1) \binom{n}{k+1} P^{k} (1 - P)^{n-k-1} - (n - k - 1) \binom{n}{k+1} P^{k+1} (1 - P)^{n-k-2} + \dots + (n - 1) \binom{n}{n-1} P^{n-2} (1 - P)^1 - \binom{n}{n-1} P^{n-1} (1 - P)^0 + n \binom{n}{n} P^{n-1} (1 - P)^0 - 0</script><p>而</p><script type="math/tex; mode=display">\begin{aligned}(n - i) \binom{n}{i} = (n - i) \frac{n!}{i! (n - i)!} = \frac{n!}{i! (n - i - 1)!} (i + 1) \binom{n}{i+1} = (i + 1) \frac{n!}{(i + 1)! (n - i - 1)!} = \frac{n!}{i! (n - i - 1)!}\end{aligned}</script><p>因此：</p><script type="math/tex; mode=display">(n - i) \binom{n}{i} = (i + 1) \binom{n}{i+1}</script><p>所以左式求导得到可相消的式子，进而有：</p><script type="math/tex; mode=display">\frac{d}{d P} \left[ \sum_{i=k}^n \binom{n}{i} P^i (1 - P)^{n-i} \right] = k \binom{n}{k} P^{k-1} (1 - P)^{n-k}</script><p>所以：</p><script type="math/tex; mode=display">\begin{aligned}\frac{d}{d P} \left[ k \binom{n}{k} \int_{0}^P x^{k-1} (1 - x)^{n-k} \, dx \right] = \frac{d}{d P} \left[ \sum_{i=k}^n \binom{n}{i} P^i (1 - P)^{n-i} \right] \end{aligned}</script><p>进而</p><script type="math/tex; mode=display">\begin{aligned}k \binom{n}{k} \int_{0}^P x^{k-1} (1 - x)^{n-k} \, dx = \sum_{i=k}^n \binom{n}{i} P^i (1 - P)^{n-i} + C \text{（C为与P无关的“常”数）} \xrightarrow{P=0} C = 0\end{aligned}</script><p>故等式得证。</p><p>因此：</p><script type="math/tex; mode=display">F_{X_{(k)}}(x) = P(X_{(k)} \le x) = \sum_{i = k}^n \binom{n}{i} P^i (1 - P)^{n-i} = k \binom{n}{k} \int_{0}^P x^{k-1} (1 - x)^{n-k} \, dx</script><p>求导得到 $ X_{(k)} $ 的概率密度函数为：</p><script type="math/tex; mode=display">f_{X_{(k)}}(x) = k \binom{n}{k} [F(x)]^{k-1} [1 - F(x)]^{n-k} f(x)</script><h3 id="从离散化与概率重构角度思考此方法"><a href="#从离散化与概率重构角度思考此方法" class="headerlink" title="从离散化与概率重构角度思考此方法"></a>从离散化与概率重构角度思考此方法</h3><p>令随机变量 $Y$ 表示随机样本中样本值小于等于 $x$ 的个数，那么单个次序统计量的概率分布可以表达为：</p><script type="math/tex; mode=display">P(X_{(k)} \le x) = P(Y \ge k)</script><p>这是一个相当朴素的思想，其后续的推导步骤与基于分布函数的推导过程实质上毫无差异。若将两者视为独立推导方法，则它们在本质上是完全等价的。然而，这一基础思想深刻揭示了后者的内在本质，即通过分布函数的定义，巧妙结合次序统计量所具有的有限性特征，成功将一个连续型随机变量的分布函数离散化处理。在此基础上，我们得以将概率重新构建为求和的形式，而非传统的积分或代入求导方式。这一转变在某种程度上为后续进行变量变换与消元提供了坚实的理论支撑。</p><p>在后续对两个次序统计量联合概率密度的推导综述中，若直接从联合分布函数出发，问题可能会显得异常复杂且难以处理。然而，上述这一基础性的本质思想却为我们提供了解决该难题的有效途径。</p><h2 id="利用概率微元的推导"><a href="#利用概率微元的推导" class="headerlink" title="利用概率微元的推导"></a>利用概率微元的推导</h2><p>教材在证明连续型随机变量在某值处的概率为 0 时，采用了概率微元的概念，即：</p><script type="math/tex; mode=display">P(x \le X \le x + \Delta x) = f(x) \Delta x</script><p>这里将概率微元写为：</p><script type="math/tex; mode=display">P(x \le X \le x + dx) = f(x) dx + o(dx)</script><p>有：</p><script type="math/tex; mode=display">f_{X_{(k)}}(x) = \lim_{\Delta x \to 0} \frac{P(x \le X_{(k)} \le x + \Delta x) + o(\Delta x)}{\Delta x} = \lim_{\Delta x \to 0} \frac{P(x \le X_{(k)} \le x + \Delta x)}{\Delta x}</script><p>由于总体为连续型随机变量，可以将整个一维数轴不重不漏地划分为 $ (-\infty, x) $, $ [x, x + \Delta x) $, $ [x + \Delta x, +\infty) $ 三部分，且 $ \Delta x \to 0 $ 时，几乎一定可以使 $ [x, x + \Delta x) $ 只包含一个样本点。</p><p>在上述基础上，$ x \le X_{(k)} \le x + \Delta x $ 等价于有 $ k - 1 $ 个样本点的值小于 $ x $，有且仅有 1 个样本的值在 $ [x, x + \Delta x) $ 中，其余 $ n - k $ 个样本点的值大于等于 $ x + \Delta x $，因此有：</p><script type="math/tex; mode=display">\begin{aligned} P(x \le X_{(k)} \le x + \Delta x) =  \binom{n}{k-1} [F(x)]^{k-1} \binom{n - k + 1}{1} \left[ F(x + \Delta x) - F(x) \right] \binom{n - k}{n - k} [1 - F(x + \Delta x)]^{n - k} =  \frac{n!}{(k - 1)! (n - k + 1)!} \cdot \frac{(n - k + 1)!}{1! (n - k)!} \cdot 1 \cdot [F(x)]^{k-1} \left[ F(x + \Delta x) - F(x) \right] [1 - F(x + \Delta x)]^{n - k} =  k \binom{n}{k} [F(x)]^{k-1} \left[ F(x + \Delta x) - F(x) \right] [1 - F(x + \Delta x)]^{n - k}\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}\therefore f_{X_{(k)}}(x) = k \binom{n}{k} \lim_{\Delta x \to 0} \frac{F(x + \Delta x) - F(x)}{\Delta x} [F(x)]^{k-1} [1 - F(x + \Delta x)]^{n - k} = k \binom{n}{k} f(x) [F(x)]^{k-1} [1 - F(x)]^{n - k}\end{aligned}</script><h2 id="连续型与离散型随机变量在次序统计量分布推导中的区别"><a href="#连续型与离散型随机变量在次序统计量分布推导中的区别" class="headerlink" title="连续型与离散型随机变量在次序统计量分布推导中的区别"></a>连续型与离散型随机变量在次序统计量分布推导中的区别</h2><p>在连续型随机变量中，单个次序统计量分布的推导可以通过概率微元的方法极大地简化。该方法基于连续型随机变量的特性，即能够将整个一维数轴不重不漏地划分为三个区间：$(-\infty, x)$、$[x, x + \Delta x)$ 和 $[x + \Delta x, +\infty)$，并且当 $\Delta x \to 0$ 时，$[x, x + \Delta x)$ 区间几乎一定只包含一个样本点。</p><p>然而，在离散型随机变量中，数轴被划分为 $(-\infty, x)$、${x}$ 和 $(x, +\infty)$（这里没有 $\Delta x$ 或 $dx$ 的概念）。由于离散型随机变量的值可能重复，多个样本点的值可能均为 $x$，这导致需要考虑多种情况，使得问题变得复杂。因此，模仿连续型随机变量对 $\mathbb{R}$ 进行划分的方法在离散型随机变量中失效。这是连续型随机变量与离散型随机变量在单个次序统计量分布推导上的根本区别。</p><p>尽管如此，基于分布函数定义的思想仍然是正确的。</p><h3 id="离散型随机变量值的可重复性"><a href="#离散型随机变量值的可重复性" class="headerlink" title="离散型随机变量值的可重复性"></a>离散型随机变量值的可重复性</h3><p>离散型随机变量值是具有可重复性的：</p><p>以 $X_{(k)} \le x$ 为例，该事件等价于至少有 $k$ 个样本点的值小于等于 $x$。因此，单个次序统计量的分布函数可以表示为各种情况的概率之和。关键在于，除去小于等于 $x$ 的点，其他点的概率值应取大于 $x$，还是大于等于 $x$？</p><ul><li><strong>若取大于$x$</strong>：这与离散型随机变量值的可重复性存在矛盾。如图 1 所示，当计算到有 $k$ 个样本小于等于 $x$ 时，按照这种算法，会导致 $ X_{(k+1)} = X_{(k+2)} = x $ 的情况被忽略。</li><li><strong>若取大于等于$x$</strong>：则每种情况的概率之和可能超过 1，而非二项分布的形式，其合理性有待讨论。</li></ul><p>Wiki 对该问题采取了后者的策略，但我认为这个问题仍有待讨论，因此这里不再作推导，以免违背严谨性。</p><h1 id="多个次序统计量的联合概率分布"><a href="#多个次序统计量的联合概率分布" class="headerlink" title="多个次序统计量的联合概率分布"></a>多个次序统计量的联合概率分布</h1><h2 id="延展概率微元方法做推导"><a href="#延展概率微元方法做推导" class="headerlink" title="延展概率微元方法做推导"></a>延展概率微元方法做推导</h2><p>以两个次序统计量 $X_{(i)}, X_{(j)}$ 为例。$F_{X_{(i)}, X_{(j)}}(x, y) = P(X_{(i)} \leq x, X_{(j)} \leq y) (i &lt; j)$，规定 $ x &lt; y $，否则 $F_{X_{(i)}, X_{(j)}}(x, y) = P(X_{(j)} \leq y) = F_{X_{(j)}}(y)$。</p><p>延展单个次序统计量概率微元的推导，这里将 $\mathbb{R}$ 不重不漏地划分为 $(-\infty, x), [x, x + \Delta x), [x + \Delta x, y), [y, y + \Delta y), [y + \Delta y, \infty)$。同样地，连续型随机变量能做到当 $(\Delta x, \Delta y) \to (0, 0)$ 时，$[x, x + \Delta x), [y, y + \Delta y)$ 中均仅有一个样本点。则 $x \leq X_{(i)} \leq x + \Delta x, y \leq X_{(j)} \leq y + \Delta y$ 等价于有 $i-1$ 个样本小于 $x$，有 1 个在 $[x, x + \Delta x)$ 中，有 $j-1-i$ 个在 $[x + \Delta x, y)$ 中，有 1 个在 $[y, y + \Delta y)$ 中，有 $n-j$ 样本大于 $ y $.</p><p>于是</p><script type="math/tex; mode=display">\begin{aligned} P(x \leq X_{(i)} \leq x + \Delta x, y \leq X_{(j)} \leq y + \Delta y) = {n \choose {i-1}} [F(x)]^{i-1} {n-i+1 \choose 1} [F(x + \Delta x) - F(x)] {n-i \choose j-i-1} [F(y) - F(x + \Delta x)]^{j-i+1}  {n-j+1 \choose 1} [F(y + \Delta y) - F(y)] {n-j \choose {n-j}} [1 - F(y + \Delta y)]^{n-j} = \frac{n!}{(i-1)!(n-i+1)!}(n-i+1) \frac{(n-i)!}{(j-i-1)!(n-j+1)!}(n-j+1) \cdot 1 \cdot [F(x)]^{i-1}  [F(x + \Delta x) - F(x)] [F(y) - F(x + \Delta x)]^{j-i+1} [F(y + \Delta y) - F(y)] [1 - F(y + \Delta y)]^{n-j} \overset{\bigtriangleup}{=} \frac{n!}{(i-1)!(j-i-1)!(n-j)!} g(x)\end{aligned}</script><p>根据概率微元的概念，有</p><script type="math/tex; mode=display">\begin{aligned} f_{X_{(i)}, X_{(j)}}(x, y) = \lim_{(\Delta x, \Delta y) \to (0, 0)} P(x \leq X_{(i)} \leq x + \Delta x, y \leq X_{(j)} \leq y + \Delta y) = \frac{n!}{(i-1)!(j-i-1)!(n-j)!} [F(x)]^{i-1} [F(y) - F(x)]^{j-i+1} [1 - F(y)]^{n-j} f(x) f(y)\end{aligned}</script><p>可以看到，概率微元在连续型随机变量次序统计量的讨论中有着十分重要的作用。基于这个概念，可以将两个次序统计量拓展到 $\forall r, 1 &lt; r \leq n$ 个次序统计量中。一些常见的结论如下：</p><ul><li><p>记任意 $s \in [1, n]$ 个次序统计量 $Y_i \overset{\bigtriangleup}{=} X_{(r_i)} (i=1, 2, …, s, r_1 &lt; r_2 &lt; … &lt; r_s)$ 的联合概率密度函数为</p><script type="math/tex; mode=display">f_Y(y_1, y_2, ..., y_s) = n! \prod_{j=0}^s \frac{[F(y_{j+1}) - F(y_j)]^{r_{j+1} - r_j - 1}}{(r_{j+1} - r_j - 1)!} \prod_{j=1}^s f(y_j)</script><p>其中 $r_0 = 0, r_{s+1} = n + 1, y_0 = -\infty, y_{n+1} = \infty, y_1 &lt; y_2 &lt; … &lt; y_s$。</p></li><li><p>特别地，前 $r$ 个次序统计量的联合概率密度函数为</p><script type="math/tex; mode=display">g(y_1, y_2, ..., y_r) = \frac{n!}{(n-r)!} [1 - F(y_r)]^{n-r} \prod_{i=1}^r f(y_i)</script></li></ul><h2 id="延展离散化与概率重构方法做推导"><a href="#延展离散化与概率重构方法做推导" class="headerlink" title="延展离散化与概率重构方法做推导"></a>延展离散化与概率重构方法做推导</h2><p>2.1 中阐明了一个朴素的离散化思想，在两个次序统计量中对该思想做延展。</p><p>记 $U, V$ 分别为样本中样本值小于等于 $x$、大于 $x$ 小于等于 $y$ 的个数，则</p><script type="math/tex; mode=display">F_{X_{(i)}, X_{(j)}}(x, y) = P(U \geq i, U + V \geq j) (x < y)</script><p>该转化完成了离散化的过程，$U, V$ 是离散的，概率被重构为</p><script type="math/tex; mode=display">\sum_a \sum_b P(U = a, V = b)</script><p>显然 $i \leq a \leq j, j \leq a + b \leq n$，注意这里不涉及对 $\mathbb{R}$ 进行划分，$a \leq j$ 是可取等的，故</p><script type="math/tex; mode=display">P(U = a, V = b) = \sum_{a=i}^j \sum_{b=j-a}^{n-a} P(U = a, V = b)</script><p>视每取一次样本 $X_i$ 为一个事件，则该事件只可能存在三种结果：</p><ul><li>$X_i \leq x$</li><li>$x &lt; X_i \leq y$</li><li>$y &lt; X_i \leq n$</li></ul><p>因此 $(U, V, n - U - V)$ 服从一个三项分布，则</p><script type="math/tex; mode=display">P(U = x_1, V = x_2, n - U - V = n - x_1 - x_2) = \frac{n!}{x_1! x_2! (n - x_1 - x_2)!} [F(x)]^{x_1} [F(y) - F(x)]^{x_2} [1 - F(y)]^{n - x_1 - x_2}</script><p>则</p><script type="math/tex; mode=display">F_{X_{(i)}, X_{(j)}}(x, y) = \sum_{a=i}^j \sum_{b=j-a}^{n-a} \frac{n!}{a! b! (n - a - b)!} [F(x)]^{a} [F(y) - F(x)]^{b} [1 - F(y)]^{n - a - b}</script><p>因此，记 $[F(x)]^{a} [F(y) - F(x)]^{b} [1 - F(y)]^{c} f(x) f(y) \overset{\Delta}{=} D(a, b, c)$，则有</p><script type="math/tex; mode=display">f_{X_{(i)}, X_{(j)}}(x, y) = \frac{\partial^2 F}{\partial x \partial y}= \sum_{a=i}^j \sum_{b=j-a}^{n-a} \frac{n!}{a! b! (n - a - b)!} \{ab \cdot D(a-1, b-1, n-a-b) - a(n - a - b) \cdot D(a-1, b, n-a-b-1) - b(b-1) \cdot D(a, b-2, n-a-b) + (n - a - b)b \cdot D(a, b-1, n-a-b-1)\}</script><h3 id="先讨论求和内部"><a href="#先讨论求和内部" class="headerlink" title="先讨论求和内部"></a>先讨论求和内部</h3><p>分为 $b = j - a, b \geq j - a$ 两部分，再记 $\frac{n!}{a! b! (n - a - b)!} \overset{\Delta}{=} Q(a, b)$，从 第一个式子 可得到</p><script type="math/tex; mode=display">Q(a, j - a) a (j - a) \cdot D(a-1, b-1, n-a-b) + \sum_{b=j-a+1}^{n-a} Q(a, b) ab \cdot D(a-1, b-1, n-a-b)</script><p>从第三个式子可得到</p><script type="math/tex; mode=display">\begin{aligned}    - Q(a, j - a) (j - a)(j - a - 1) \cdot D(a, b-2, n-a-b) - \sum_{b=j-a+1}^{n-a} Q(a, b) b(b-1) \cdot D(a, b-2, n-a-b)\end{aligned}</script><p>对上面两个式子的求和式做变量替换 $b’ = b - 1$，则两个求和式变为</p><script type="math/tex; mode=display">\begin{aligned}    + \sum_{b'=j-a}^{n-a-1} Q(a, b'+1) a(b'+1) \cdot D(a-1, b', n-a-b'-1) - \sum_{b'=j-a}^{n-a-1} Q(a, b'+1) b'(b'+1) \cdot D(a, b'-1, n-a-b'-1)\end{aligned}</script><p>在第二个式子和第四个式子中，当 $b = n - a$ 时式子为 0，上限修改为 $n - a - 1$，即</p><script type="math/tex; mode=display">\begin{aligned}    + \sum_{b=j-a}^{n-a-1} Q(a, b) (n - a - b) b \cdot D(a, b-1, n-a-b-1) - \sum_{b=j-a}^{n-a-1} Q(a, b) a (n - a - b) \cdot D(a-1, b, n-a-b-1)\end{aligned}</script><p>又因为</p><script type="math/tex; mode=display">Q(a, b+1) a(b+1) = \frac{n!}{a! (b+1)! (n - a - b - 1)!} a(b+1) = \frac{n!}{(a-1)! b! (n - a - b - 1)!} = Q(a, b) a(n - a - b)</script><p>同理有</p><script type="math/tex; mode=display">Q(a, b+1) b(b+1) = Q(a, b) b(n - a - b)</script><p>因此，通过相消，故</p><script type="math/tex; mode=display">f_{X_{(i)}, X_{(j)}}(x, y) = \sum_{a=i}^j [Q(a, j-a) a(j-a) \cdot D(a-1, b-1, n-a-b) - Q(a, j-a) (j-a)(j-a-1) \cdot D(a, b-2, n-a-b)]</script><p>同理地，分为 $a = i, a &gt; i$ 两部分求和，并考虑取上限时为 0 的情况，得到</p><script type="math/tex; mode=display">f_{X_{(i)}, X_{(j)}}(x, y) = Q(i, j-i) i(j-i) \cdot D(i-1, j-i-1, n-j) + \sum_{a=i+1}^{j-1} Q(a, j-a) a(j-a) \cdot D(a-1, j-a-1, n-j) - \sum_{a=i}^{j-2} Q(a, j-a) (j-a)(j-a-1) \cdot D(a, j-a-2, n-j)</script><p>对后两项和式做变量替换 $a’ = a - 1$，同理可消去得到</p><script type="math/tex; mode=display">f_{X_{(i)}, X_{(j)}}(x, y) = Q(i, j-i) i(j-i) \cdot D(i-1, j-i-1, n-j)</script><p>即</p><script type="math/tex; mode=display">f_{X_{(i)}, X_{(j)}}(x, y) = \frac{n!}{(i-1)! (j-i-1)! (n-j)!} [F(x)]^{i-1} [F(y) - F(x)]^{j-i+1} [1 - F(y)]^{n-j} f(x) f(y)</script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>山静似太古，日长如小年</title>
      <link href="/2025/01/06/%E5%B1%B1%E9%9D%99%E4%BC%BC%E5%A4%AA%E5%8F%A4%EF%BC%8C%E6%97%A5%E9%95%BF%E5%A6%82%E5%B0%8F%E5%B9%B4/"/>
      <url>/2025/01/06/%E5%B1%B1%E9%9D%99%E4%BC%BC%E5%A4%AA%E5%8F%A4%EF%BC%8C%E6%97%A5%E9%95%BF%E5%A6%82%E5%B0%8F%E5%B9%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="我有亿点困惑"><a href="#我有亿点困惑" class="headerlink" title="我有亿点困惑"></a>我有亿点困惑</h2><p> 我尝试了许多，~~问爆了我的 GPT ~~ 看了许多 bug ，终于将这份 blog 送到你面前。坦白说这并不光彩，运用一个已有的<a href="https://hexo.io/">Hexo</a>框架来搭建 blog ，实属寻常之举，我却在这一过程中遇到<br> 奇多困难，这确实地反映了我技术栈储备的匮乏。</p><p> 一个令我颇为无奈的事实是，我迫不得已地将这份 blog 部署到了 <a href="https://github.com/Minijie3/Minijie3.github.io">GitHub</a> 中，因为尽管我的 ESC 云服务器一切部署工作都已完成，却始终无法正常访问，这让我倍感困扰，我甚至为此买了域名，然而在尝试将域名解析到 GitHub Pages 时，依旧遭遇了解析成功却无法访问的窘境。将 blog 部署到 GitHub 并无法使用我自己的域名，是我预想中最为糟糕的情况。此外，在我进行参数调试时，包括但不限于<code>link(friends),tags</code>等一系列页面甚至无法成功通过 <code>hexo generate</code> 命令，均无法正常生成静态文件，而我至今未能找出其中的原因。因此，我的页面显得相当简陋，此外此站目前暂时不支持移动端访问，甚至连我自己都难以说服自己接受这种状况。然而，鉴于个人时间安排的限制，为了不影响后续计划，我不得不暂时让其上线，这让我感到十分无奈。</p><p> 我会持续努力优化这个博客，尽力解决上述提到的一些问题。不过，我必须坦诚，我刚开始学习<code>JavaScript</code>相关技术，还不具备对框架进行深度修改的能力。因此，对于那些涉及到框架核心的 bug，我只能暂时放弃，或者从参数上找问题（毕竟如此成熟的框架有问题疑似不太可能），确保当前框架的正常运行。另外，关于 ESC 服务器的问题，虽然我有一定的 Linux 服务器操作能力，但目前仍然无法解决，而移动端访问的问题同时会花费我大量的时间。我不确定需要多长时间才能彻底改善所有存在的问题，或许是几个月、一年、两年？但我会尽力而为。</p><h2 id="加速访问此站"><a href="#加速访问此站" class="headerlink" title="加速访问此站"></a>加速访问此站</h2><p> 基于 GitHub 访问时好时坏、有时甚至无法访问的尿性，想要稳定、快速地访问此站需要一定的<del>“魔法”</del>努力。我推荐且常用的是<a href="https://steampp.net/">Watt Toolkit(俗称steam++)</a>加速器，本质上它是一个为 Steam 加速而设计的加速器，但它同样可以用于加速 GitHub 访问，我已经使用了这个工具半年多，其稳定性和访问速度我还算满意。此外，我无意中发现<a href="https://uu.163.com/index.html">UU加速器</a>中有对学术网页加速的功能，尽管其列表中没有明确提到 GitHub，但实际使用中却能对 GitHub 进行加速，只是效果不太稳定。当然，如果你有其他的“魔法”手段，那这些建议可能就显得多余了（）。</p><p> 后续如果我的 ESC 服务器能够正常部署，我将考虑把此博客迁移到我的服务器上，届时访问速度与移动端的访问问题都将得到解决（虽然我还不确定移动端无法访问是否完全是因为 GitHub Pages 的问题），但这需要一定的时间。令人遗憾的是，我曾尝试将此站点部署到 Gitee Pages 上，就在我即将完成部署、为即将能够秒速访问感到欣喜时，突然发现 Gitee Pages 服务早已下线（恼。而 GitLab Pages 又不支持 Hexo 框架。希望国产代码托管平台能早日开发出支持 Hexo 框架的 Pages 服务。</p><h2 id="关于本站"><a href="#关于本站" class="headerlink" title="关于本站"></a>关于本站</h2><p> 读者应该能看出来笔者技术的匮乏，但这与我愿意来写博客作分享无关，我接受一切批评与建议，<del>如果你非要说彩笔还写博客那what can i say</del>并且自身也在努力学习。本站预计分享以下内容：</p><ol><li>数学</li><li>学习过程的各种技术小记</li><li>计算机体系结构</li><li><p>else</p><p>尽管我对LaTeX的熟练程度还不错，但我从来没有使用过markdown，本文是我第一次使用markdown来码字，当然基于我 LaTeX 的基础，我认为我可以相对轻松地学习使用markdown。</p></li></ol><h2 id="关于笔者"><a href="#关于笔者" class="headerlink" title="关于笔者"></a>关于笔者</h2><p> from Harbin Institute of Technology, Shenzhen.</p><p> <a href="mailto:https://1208352126@qq.com">QQ邮箱</a>：1208352126@qq.com，还有一个HIT 邮箱：<a href="https://2023311H13@stu.hit.edu.cn:2023311H13.stu.hit.edu.cn，推荐你使用后者联系我，因为我QQ邮箱中消息实在杂乱，我会习惯性地将里面的邮件视为trash">https://2023311H13@stu.hit.edu.cn:2023311H13.stu.hit.edu.cn，推荐你使用后者联系我，因为我QQ邮箱中消息实在杂乱，我会习惯性地将里面的邮件视为trash</a> mails.</p><p> <a href="https://github.com/Minijie3">GitHub</a>:Minijie3，我会不定期写一些小玩具push上去。</p><h2 id="let’s-go"><a href="#let’s-go" class="headerlink" title="let’s go!"></a>let’s go!</h2><p> 尽管在这个博客搭建过程中遇到了诸多挑战，我依然充满热情地开始了这段旅程。正如题目所言，“山静似太古，日长如小年”，我情愿以耐心与毅力去应对每一次的挫败，作为一个极度享受孤独的人，这些是我成长的契机。我承认我是一个小白，但是我希望通过记录自己的学习过程，激励同样在技术道路上摸索前行的你。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
